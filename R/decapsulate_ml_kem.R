
#' Shared Secret - Retrieve ML-KEM (FIPS 203)
#'
#' @description
#' Uses own private key to retrieve the shared secret key created by `encapsulate_ml_kem()`.
#'
#' @param encapsulation Received encapsulation object created by `encapsulate_ml_kem()`
#' @param private_key   Receiver's private key as generated by `keygen_ml_kem()`.
#'
#' @return The shared secret
#'
#' @export
#'
#' @examples
#' key <- keygen_ml_kem(512)
#' ss1 <- encapsulate_ml_kem(key$public)  # This generates an encapsulation readable only by key$private
#' ss2 <- decapsulate_ml_kem(ss1$encapsulation, key$private)
#' identical(ss1$shared_secret, ss2)
#'
decapsulate_ml_kem <- function(encapsulation, private_key) {

  if (!inherits(encapsulation, "pqcrypto_encapsulation")) {
    pq_stop(c(x = "'encapsulation' parameter does not have the expected class.",
              i = "'encapsulation' must have `pqcrypto_encapsulation` class."))
  }

  if (!inherits(private_key, "pqcrypto_private_key")) {
    pq_stop(c(x = "'private_key' parameter does not have the expected class.",
              i = "'private_key' must have `pqcrypto_private_key` class."))
  }

  if (!grepl("1.3.6.1.4.1.54392.5.1859.1.1.?", attr(private_key, "algorithm"))) {
    pq_stop(c(x = "Wrong private key algorithm.",
              i = "Make sure you are using a 'ML-KEM' private key."))
  }

  encap_len <- length(encapsulation)
  if (attr(private_key, "algorithm") == "1.3.6.1.4.1.54392.5.1859.1.1.1") {
    if (encap_len != 768) {
      pq_stop(c(x = "Encapsulation size mismatch with the expected size for the private key used.",
                i = "Make sure you are using right private key."))
    }
    out <- cpp_decap_kyber512(private_key, encapsulation)
  } else if (attr(private_key, "algorithm") == "1.3.6.1.4.1.54392.5.1859.1.1.2") {
    if (encap_len != 1088) {
      pq_stop(c(x = "Encapsulation size mismatch with the expected size for the private key used.",
                i = "Make sure you are using right private key."))
    }
    out <- cpp_decap_kyber768(private_key, encapsulation)
  } else if (attr(private_key, "algorithm") == "1.3.6.1.4.1.54392.5.1859.1.1.3") {
    if (encap_len != 1568) {
      pq_stop(c(x = "Encapsulation size mismatch with the expected size for the private key used.",
                i = "Make sure you are using right private key."))
    }
    out <- cpp_decap_kyber1024(private_key, encapsulation)
  } else {
    pq_stop(c(x = "The suplied private key has invalid parameters."))
  }
  class(out) <- "pqcrypto_shared_secret"

  invisible(out)
}

#' Kyber Shared Secret - Retrieve
#'
#' @description
#' `r lifecycle::badge("deprecated")`
#' Uses own private key to retrieve the shared secret key created by `encapsulate_ml_kem()`.
#'
#' @param encapsulation Received encapsulation object created by `encapsulate_ml_kem()`
#' @param private_key   Receiver's private key as generated by `keygen_ml_kem()`.
#'
#' @return The shared secret
#'
#' @export
#' @keywords internal
#'
#' @examples
#' key <- keygen_ml_kem(512)
#' ss1 <- encapsulate_ml_kem(key$public)  # This generates an encapsulation readable only by key$private
#'
#' ss2 <- decap_kyber(ss1$encapsulation, key$private)
#' # ->
#' ss3 <- decapsulate_ml_kem(ss1$encapsulation, key$private)
#' identical(ss1$shared_secret, ss2)
#' identical(ss1$shared_secret, ss1)
#'
decap_kyber <- function(encapsulation, private_key) {
  lifecycle::deprecate_soft("0.3.0", "decap_kyber()", "decapsulate_ml_kem()")

  decapsulate_ml_kem(encapsulation, private_key)

}
